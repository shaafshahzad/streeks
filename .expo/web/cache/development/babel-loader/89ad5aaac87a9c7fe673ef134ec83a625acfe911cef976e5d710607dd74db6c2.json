{"ast":null,"code":"import { interpolate, Extrapolation } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\nexport var serialize = function serialize(path) {\n  \"worklet\";\n\n  return \"M\" + path.move.x + \",\" + path.move.y + \" \" + path.curves.map(function (c) {\n    return \"C\" + c.c1.x + \",\" + c.c1.y + \" \" + c.c2.x + \",\" + c.c2.y + \" \" + c.to.x + \",\" + c.to.y;\n  }).join(\" \") + (path.close ? \"Z\" : \"\");\n};\nexport var parse = function parse(d) {\n  var segments = normalizeSVG(absSVG(parseSVG(d)));\n  var path = createPath({\n    x: segments[0][1],\n    y: segments[0][2]\n  });\n  segments.forEach(function (segment) {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2]\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4]\n        },\n        to: {\n          x: segment[5],\n          y: segment[6]\n        }\n      });\n    }\n  });\n  return path;\n};\nexport var interpolatePath = function interpolatePath(value, inputRange, outputRange) {\n  \"worklet\";\n\n  var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Extrapolation.CLAMP;\n  var path = {\n    move: {\n      x: interpolate(value, inputRange, outputRange.map(function (p) {\n        return p.move.x;\n      }), extrapolate),\n      y: interpolate(value, inputRange, outputRange.map(function (p) {\n        return p.move.y;\n      }), extrapolate)\n    },\n    curves: outputRange[0].curves.map(function (_, index) {\n      return {\n        c1: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c1.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c1.y;\n          }), extrapolate)\n        },\n        c2: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c2.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c2.y;\n          }), extrapolate)\n        },\n        to: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].to.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].to.y;\n          }), extrapolate)\n        }\n      };\n    }),\n    close: outputRange[0].close\n  };\n  return serialize(path);\n};\nexport var mixPath = function mixPath(value, p1, p2) {\n  \"worklet\";\n\n  var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Extrapolation.CLAMP;\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\nexport var createPath = function createPath(move) {\n  \"worklet\";\n\n  return {\n    move: move,\n    curves: [],\n    close: false\n  };\n};\nexport var addArc = function addArc(path, corner, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  var arc = 9 / 16;\n  path.curves.push({\n    c1: {\n      x: (corner.x - from.x) * arc + from.x,\n      y: (corner.y - from.y) * arc + from.y\n    },\n    c2: {\n      x: (corner.x - to.x) * arc + to.x,\n      y: (corner.y - to.y) * arc + to.y\n    },\n    to: to\n  });\n};\nexport var addCurve = function addCurve(path, c) {\n  \"worklet\";\n\n  path.curves.push({\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to\n  });\n};\nexport var addLine = function addLine(path, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  path.curves.push({\n    c1: from,\n    c2: to,\n    to: to\n  });\n};\nexport var addQuadraticCurve = function addQuadraticCurve(path, cp, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  path.curves.push({\n    c1: {\n      x: from.x / 3 + 2 / 3 * cp.x,\n      y: from.y / 3 + 2 / 3 * cp.y\n    },\n    c2: {\n      x: to.x / 3 + 2 / 3 * cp.x,\n      y: to.y / 3 + 2 / 3 * cp.y\n    },\n    to: to\n  });\n};\nexport var close = function close(path) {\n  \"worklet\";\n\n  path.close = true;\n};\nvar curveIsFound = function curveIsFound(c) {\n  \"worklet\";\n\n  return c.curve !== null;\n};\nexport var selectCurve = function selectCurve(path, x) {\n  \"worklet\";\n\n  var result = {\n    from: path.move,\n    curve: null\n  };\n  for (var i = 0; i < path.curves.length; i++) {\n    var c = path.curves[i];\n    var contains = result.from.x > c.to.x ? x >= c.to.x && x <= result.from.x : x >= result.from.x && x <= c.to.x;\n    if (contains) {\n      result.curve = c;\n      break;\n    }\n    result.from = c.to;\n  }\n  if (!curveIsFound(result)) {\n    return null;\n  }\n  return result;\n};\nexport var getYForX = function getYForX(path, x) {\n  \"worklet\";\n\n  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var c = selectCurve(path, x);\n  if (c === null) {\n    return null;\n  }\n  return cubicBezierYForX(x, c.from, c.curve.c1, c.curve.c2, c.curve.to, precision);\n};\nvar controlPoint = function controlPoint(current, previous, next, reverse, smoothing) {\n  \"worklet\";\n\n  var p = previous || current;\n  var n = next || current;\n  var lengthX = n.x - p.x;\n  var lengthY = n.y - p.y;\n  var o = cartesian2Polar({\n    x: lengthX,\n    y: lengthY\n  });\n  var angle = o.theta + (reverse ? Math.PI : 0);\n  var length = o.radius * smoothing;\n  var x = current.x + Math.cos(angle) * length;\n  var y = current.y + Math.sin(angle) * length;\n  return {\n    x: x,\n    y: y\n  };\n};\nvar exhaustiveCheck = function exhaustiveCheck(a) {\n  throw new Error(\"Unexhaustive handling for \" + a);\n};\nexport var curveLines = function curveLines(points, smoothing, strategy) {\n  \"worklet\";\n\n  var path = createPath(points[0]);\n  for (var i = 0; i < points.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n    var point = points[i];\n    var next = points[i + 1];\n    var prev = points[i - 1];\n    var cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n    var cpe = controlPoint(point, prev, next, true, smoothing);\n    switch (strategy) {\n      case \"simple\":\n        var cp = {\n          x: (cps.x + cpe.x) / 2,\n          y: (cps.y + cpe.y) / 2\n        };\n        addQuadraticCurve(path, cp, point);\n        break;\n      case \"bezier\":\n        var p0 = points[i - 2] || prev;\n        var p1 = points[i - 1];\n        var cp1x = (2 * p0.x + p1.x) / 3;\n        var cp1y = (2 * p0.y + p1.y) / 3;\n        var cp2x = (p0.x + 2 * p1.x) / 3;\n        var cp2y = (p0.y + 2 * p1.y) / 3;\n        var cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n        var cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n        path.curves.push({\n          c1: {\n            x: cp1x,\n            y: cp1y\n          },\n          c2: {\n            x: cp2x,\n            y: cp2y\n          },\n          to: {\n            x: cp3x,\n            y: cp3y\n          }\n        });\n        if (i === points.length - 1) {\n          path.curves.push({\n            to: points[points.length - 1],\n            c1: points[points.length - 1],\n            c2: points[points.length - 1]\n          });\n        }\n        break;\n      case \"complex\":\n        path.curves.push({\n          to: point,\n          c1: cps,\n          c2: cpe\n        });\n        break;\n      default:\n        exhaustiveCheck(strategy);\n    }\n  }\n  return path;\n};","map":{"version":3,"names":["interpolate","Extrapolation","parseSVG","absSVG","normalizeSVG","cartesian2Polar","cubicBezierYForX","serialize","path","move","x","y","curves","map","c","c1","c2","to","join","close","parse","d","segments","createPath","forEach","segment","addCurve","interpolatePath","value","inputRange","outputRange","extrapolate","arguments","length","undefined","CLAMP","p","_","index","mixPath","p1","p2","addArc","corner","last","from","arc","push","addLine","addQuadraticCurve","cp","curveIsFound","curve","selectCurve","result","i","contains","getYForX","precision","controlPoint","current","previous","next","reverse","smoothing","n","lengthX","lengthY","o","angle","theta","Math","PI","radius","cos","sin","exhaustiveCheck","a","Error","curveLines","points","strategy","point","prev","cps","cpe","p0","cp1x","cp1y","cp2x","cp2y","cp3x","cp3y"],"sources":["/Users/shaaf/repos/streek/node_modules/react-native-redash/lib/module/Paths.ts"],"sourcesContent":["import { interpolate, Extrapolation } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport type { Vector } from \"./Vectors\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand,\n  ...(SVGCurveCommand | SVGCloseCommand)[]\n];\n\ninterface Curve {\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\nexport type Path = {\n  move: Vector;\n  curves: Curve[];\n  close: boolean;\n};\n\n/**\n * @summary Serialize a path into an SVG path string\n * @worklet\n */\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return `M${path.move.x},${path.move.y} ${path.curves\n    .map((c) => `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y}`)\n    .join(\" \")}${path.close ? \"Z\" : \"\"}`;\n};\n\n/**\n * @description ⚠️ this function cannot run on the UI thread. It must be executed on the JS thread\n * @summary Parse an SVG path into a sequence of Bèzier curves.\n * The SVG is normalized to have absolute values and to be approximated to a sequence of Bèzier curves.\n */\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  const path = createPath({ x: segments[0][1], y: segments[0][2] });\n  segments.forEach((segment) => {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n      });\n    }\n  });\n  return path;\n};\n\n/**\n * @summary Interpolate between paths.\n * @worklet\n */\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[],\n  extrapolate = Extrapolation.CLAMP\n) => {\n  \"worklet\";\n  const path = {\n    move: {\n      x: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.x),\n        extrapolate\n      ),\n      y: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.y),\n        extrapolate\n      ),\n    },\n    curves: outputRange[0].curves.map((_, index) => ({\n      c1: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.y),\n          extrapolate\n        ),\n      },\n      c2: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.y),\n          extrapolate\n        ),\n      },\n      to: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.y),\n          extrapolate\n        ),\n      },\n    })),\n    close: outputRange[0].close,\n  };\n  return serialize(path);\n};\n\n/**\n * @summary Interpolate two paths with an animation value that goes from 0 to 1\n * @worklet\n */\nexport const mixPath = (\n  value: number,\n  p1: Path,\n  p2: Path,\n  extrapolate = Extrapolation.CLAMP\n) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\n\n/**\n * @summary Create a new path\n * @worklet\n */\nexport const createPath = (move: Vector): Path => {\n  \"worklet\";\n  return {\n    move,\n    curves: [],\n    close: false,\n  };\n};\n\n/**\n * @summary Add an arc command to a path\n * @worklet\n */\nexport const addArc = (path: Path, corner: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  const arc = 9 / 16;\n  path.curves.push({\n    c1: {\n      x: (corner.x - from.x) * arc + from.x,\n      y: (corner.y - from.y) * arc + from.y,\n    },\n    c2: {\n      x: (corner.x - to.x) * arc + to.x,\n      y: (corner.y - to.y) * arc + to.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a cubic Bèzier curve command to a path.\n * @worklet\n */\nexport const addCurve = (path: Path, c: Curve) => {\n  \"worklet\";\n  path.curves.push({\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n  });\n};\n\n/**\n * @summary Add a line command to a path.\n * @worklet\n */\nexport const addLine = (path: Path, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: from,\n    c2: to,\n    to,\n  });\n};\n\n/**\n * @summary Add a quadratic Bèzier curve command to a path.\n * @worklet\n */\nexport const addQuadraticCurve = (path: Path, cp: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: {\n      x: from.x / 3 + (2 / 3) * cp.x,\n      y: from.y / 3 + (2 / 3) * cp.y,\n    },\n    c2: {\n      x: to.x / 3 + (2 / 3) * cp.x,\n      y: to.y / 3 + (2 / 3) * cp.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a close command to a path.\n * @worklet\n */\nexport const close = (path: Path) => {\n  \"worklet\";\n  path.close = true;\n};\n\ninterface SelectedCurve {\n  from: Vector;\n  curve: Curve;\n}\n\ninterface NullableSelectedCurve {\n  from: Vector;\n  curve: Curve | null;\n}\n\n/**\n * @worklet\n */\nconst curveIsFound = (c: NullableSelectedCurve): c is SelectedCurve => {\n  \"worklet\";\n  return c.curve !== null;\n};\n\n/**\n * @summary Return the curves at x. This function assumes that only one curve is available at x\n * @worklet\n */\nexport const selectCurve = (path: Path, x: number): SelectedCurve | null => {\n  \"worklet\";\n  const result: NullableSelectedCurve = {\n    from: path.move,\n    curve: null,\n  };\n  for (let i = 0; i < path.curves.length; i++) {\n    const c = path.curves[i];\n    const contains =\n      result.from.x > c.to.x\n        ? x >= c.to.x && x <= result.from.x\n        : x >= result.from.x && x <= c.to.x;\n    if (contains) {\n      result.curve = c;\n      break;\n    }\n    result.from = c.to;\n  }\n  if (!curveIsFound(result)) {\n    return null;\n  }\n  return result;\n};\n\n/**\n * @summary Return the y value of a path given its x coordinate\n * @example\n    const p1 = parse(\n      \"M150,0 C150,0 0,75 200,75 C75,200 200,225 200,225 C225,200 200,150 0,150\"\n    );\n    // 75\n    getYForX(p1, 200))\n    // ~151\n    getYForX(p1, 50)\n * @worklet\n */\nexport const getYForX = (path: Path, x: number, precision = 2) => {\n  \"worklet\";\n  const c = selectCurve(path, x);\n  if (c === null) {\n    return null;\n  }\n  return cubicBezierYForX(\n    x,\n    c.from,\n    c.curve.c1,\n    c.curve.c2,\n    c.curve.to,\n    precision\n  );\n};\n\nconst controlPoint = (\n  current: Vector,\n  previous: Vector,\n  next: Vector,\n  reverse: boolean,\n  smoothing: number\n) => {\n  \"worklet\";\n  const p = previous || current;\n  const n = next || current;\n  // Properties of the opposed-line\n  const lengthX = n.x - p.x;\n  const lengthY = n.y - p.y;\n\n  const o = cartesian2Polar({ x: lengthX, y: lengthY });\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.theta + (reverse ? Math.PI : 0);\n  const length = o.radius * smoothing;\n  // The control point position is relative to the current point\n  const x = current.x + Math.cos(angle) * length;\n  const y = current.y + Math.sin(angle) * length;\n  return { x, y };\n};\n\nconst exhaustiveCheck = (a: never): never => {\n  throw new Error(`Unexhaustive handling for ${a}`);\n};\n\n/**\n * @summary Link points via a smooth cubic Bézier curves\n * from https://github.com/rainbow-me/rainbow\n * @worklet\n */\nexport const curveLines = (\n  points: Vector<number>[],\n  smoothing: number,\n  strategy: \"complex\" | \"bezier\" | \"simple\"\n) => {\n  \"worklet\";\n  const path = createPath(points[0]);\n  // build the d attributes by looping over the points\n  for (let i = 0; i < points.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n    const point = points[i];\n    const next = points[i + 1];\n    const prev = points[i - 1];\n    const cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n    const cpe = controlPoint(point, prev, next, true, smoothing);\n    switch (strategy) {\n      case \"simple\":\n        const cp = {\n          x: (cps.x + cpe.x) / 2,\n          y: (cps.y + cpe.y) / 2,\n        };\n        addQuadraticCurve(path, cp, point);\n        break;\n      case \"bezier\":\n        const p0 = points[i - 2] || prev;\n        const p1 = points[i - 1];\n        const cp1x = (2 * p0.x + p1.x) / 3;\n        const cp1y = (2 * p0.y + p1.y) / 3;\n        const cp2x = (p0.x + 2 * p1.x) / 3;\n        const cp2y = (p0.y + 2 * p1.y) / 3;\n        const cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n        const cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n        path.curves.push({\n          c1: { x: cp1x, y: cp1y },\n          c2: { x: cp2x, y: cp2y },\n          to: { x: cp3x, y: cp3y },\n        });\n        if (i === points.length - 1) {\n          path.curves.push({\n            to: points[points.length - 1],\n            c1: points[points.length - 1],\n            c2: points[points.length - 1],\n          });\n        }\n        break;\n      case \"complex\":\n        path.curves.push({\n          to: point,\n          c1: cps,\n          c2: cpe,\n        });\n        break;\n      default:\n        exhaustiveCheck(strategy);\n    }\n  }\n  return path;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}